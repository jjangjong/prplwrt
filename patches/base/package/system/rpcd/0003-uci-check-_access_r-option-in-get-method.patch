From 1a5ddc55129639a468c456eba081392ecbba60b8 Mon Sep 17 00:00:00 2001
From: Denis Osvald <denis.osvald@sartura.hr>
Date: Fri, 8 Jul 2016 18:11:44 +0200
Subject: [PATCH 3/4] uci: check _access_r option in get method

Don't show sections which have a _access_r option (username or list of
usernames) to users not in that list.

Signed-off-by: Denis Osvald <denis.osvald@sartura.hr>
---
 uci.c | 49 ++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 40 insertions(+), 9 deletions(-)

diff --git a/uci.c b/uci.c
index 08ad3de..d011746 100644
--- a/uci.c
+++ b/uci.c
@@ -482,7 +482,7 @@ rpc_uci_match_section(struct uci_section *s,
  *  2) If the uci_option is of type string, put its value directly into the blob
  *     buffer.
  */
-static void
+static int
 rpc_uci_dump_option(struct uci_option *o, const char *name)
 {
 	void *c;
@@ -506,6 +506,8 @@ rpc_uci_dump_option(struct uci_option *o, const char *name)
 	default:
 		break;
 	}
+
+	return 1;
 }
 
 /*
@@ -516,12 +518,16 @@ rpc_uci_dump_option(struct uci_option *o, const char *name)
  * Adds three special keys ".anonymous", ".type" and ".name" which specify the
  * corresponding section properties.
  */
-static void
-rpc_uci_dump_section(struct uci_section *s, const char *name, int index)
+static int
+rpc_uci_dump_section(struct uci_section *s, const char *name, int index, const char *username)
 {
 	void *c;
 	struct uci_option *o;
 	struct uci_element *e;
+	int count = 0;
+
+	if (!rpc_uci_section_access(username, s, 'r'))
+		return 0;
 
 	c = blobmsg_open_table(&buf, name);
 
@@ -535,10 +541,11 @@ rpc_uci_dump_section(struct uci_section *s, const char *name, int index)
 	uci_foreach_element(&s->options, e)
 	{
 		o = uci_to_option(e);
-		rpc_uci_dump_option(o, o->e.name);
+		count += rpc_uci_dump_option(o, o->e.name);
 	}
 
 	blobmsg_close_table(&buf, c);
+	return count;
 }
 
 /*
@@ -549,13 +556,14 @@ rpc_uci_dump_section(struct uci_section *s, const char *name, int index)
  * Only dumps sections matching the given "type" and "matches", see explaination
  * of rpc_uci_match_section() for details.
  */
-static void
+static int
 rpc_uci_dump_package(struct uci_package *p, const char *name,
-                     struct blob_attr *type, struct blob_attr *matches)
+                     struct blob_attr *type, struct blob_attr *matches, const char *username)
 {
 	void *c;
 	struct uci_element *e;
 	int i = -1;
+	int count = 0;
 
 	c = blobmsg_open_table(&buf, name);
 
@@ -566,10 +574,12 @@ rpc_uci_dump_package(struct uci_package *p, const char *name,
 		if (!rpc_uci_match_section(uci_to_section(e), type, matches))
 			continue;
 
-		rpc_uci_dump_section(uci_to_section(e), e->name, i);
+		count += rpc_uci_dump_section(uci_to_section(e), e->name, i, username);
 	}
 
 	blobmsg_close_table(&buf, c);
+
+	return count;
 }
 
 
@@ -580,6 +590,8 @@ rpc_uci_getcommon(struct ubus_context *ctx, struct ubus_request_data *req,
 	struct blob_attr *tb[__RPC_G_MAX];
 	struct uci_package *p = NULL;
 	struct uci_ptr ptr = { 0 };
+	const char *username;
+	int count;
 
 	blobmsg_parse(rpc_uci_get_policy, __RPC_G_MAX, tb,
 	              blob_data(msg), blob_len(msg));
@@ -611,18 +623,37 @@ rpc_uci_getcommon(struct ubus_context *ctx, struct ubus_request_data *req,
 
 	blob_buf_init(&buf, 0);
 
+	username = rpc_session_get_username(tb[RPC_G_SESSION]);
+
 	switch (ptr.last->type)
 	{
 	case UCI_TYPE_PACKAGE:
-		rpc_uci_dump_package(ptr.p, "values", tb[RPC_G_TYPE], tb[RPC_G_MATCH]);
+		// pass in username so dump can skip sections which are not allowed
+		count = rpc_uci_dump_package(ptr.p, "values", tb[RPC_G_TYPE], tb[RPC_G_MATCH], username);
 		break;
 
 	case UCI_TYPE_SECTION:
-		rpc_uci_dump_section(ptr.s, "values", -1);
+		count = rpc_uci_dump_section(ptr.s, "values", -1, username);
+
+		if (!count) {
+			// section skipped due to access, behave as if no such section
+			blob_buf_free(&buf);
+			uci_unload(cursor, p);
+			return UBUS_STATUS_OK;
+		}
+
 		break;
 
 	case UCI_TYPE_OPTION:
+		// option skipped due to access, behave as if no such option
+		if (!rpc_uci_option_access(username, ptr.o, 'r')) {
+			blob_buf_free(&buf);
+			uci_unload(cursor, p);
+			return UBUS_STATUS_OK;
+		}
+
 		rpc_uci_dump_option(ptr.o, "value");
+
 		break;
 
 	default:
-- 
2.9.0

