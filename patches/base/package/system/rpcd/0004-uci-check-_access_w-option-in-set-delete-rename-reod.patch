From 62e9a6a1151cab15cdc636b9ede25053c52fa470 Mon Sep 17 00:00:00 2001
From: Denis Osvald <denis.osvald@sartura.hr>
Date: Fri, 8 Jul 2016 18:14:07 +0200
Subject: [PATCH 4/4] uci: check _access_w option in set, delete, rename,
 reodrder methods

If username from session is not in _access_w list for some section,
ignore delete, set, rename, reorder oprations on that section.

Signed-off-by: Denis Osvald <denis.osvald@sartura.hr>
---
 uci.c | 38 ++++++++++++++++++++++++++++++--------
 1 file changed, 30 insertions(+), 8 deletions(-)

diff --git a/uci.c b/uci.c
index d011746..6db05b5 100644
--- a/uci.c
+++ b/uci.c
@@ -778,7 +778,7 @@ out:
  *     option of if the existing options value differs from the blob value
  */
 static void
-rpc_uci_merge_set(struct blob_attr *opt, struct uci_ptr *ptr)
+rpc_uci_merge_set(struct blob_attr *opt, struct uci_ptr *ptr, const char *username)
 {
 	struct blob_attr *cur;
 	int rem;
@@ -790,6 +790,9 @@ rpc_uci_merge_set(struct blob_attr *opt, struct uci_ptr *ptr)
 	if (rpc_uci_lookup(ptr) || !ptr->s)
 		return;
 
+	if (!rpc_uci_section_access(username, ptr->s, 'w'))
+		return;
+
 	if (blobmsg_type(opt) == BLOBMSG_TYPE_ARRAY)
 	{
 		if (ptr->o)
@@ -824,6 +827,7 @@ rpc_uci_set(struct ubus_context *ctx, struct ubus_object *obj,
 	struct uci_element *e;
 	struct uci_ptr ptr = { 0 };
 	int rem;
+	const char *username;
 
 	blobmsg_parse(rpc_uci_set_policy, __RPC_S_MAX, tb,
 	              blob_data(msg), blob_len(msg));
@@ -840,11 +844,13 @@ rpc_uci_set(struct ubus_context *ctx, struct ubus_object *obj,
 	if (uci_load(cursor, ptr.package, &p))
 		return rpc_uci_status();
 
+	username = rpc_session_get_username(tb[RPC_S_SESSION]);
+
 	if (tb[RPC_S_SECTION])
 	{
 		ptr.section = blobmsg_data(tb[RPC_S_SECTION]);
 		blobmsg_for_each_attr(cur, tb[RPC_S_VALUES], rem)
-			rpc_uci_merge_set(cur, &ptr);
+			rpc_uci_merge_set(cur, &ptr, username);
 	}
 	else
 	{
@@ -858,7 +864,7 @@ rpc_uci_set(struct ubus_context *ctx, struct ubus_object *obj,
 			ptr.section = e->name;
 
 			blobmsg_for_each_attr(cur, tb[RPC_S_VALUES], rem)
-				rpc_uci_merge_set(cur, &ptr);
+				rpc_uci_merge_set(cur, &ptr, username);
 		}
 	}
 
@@ -875,7 +881,7 @@ rpc_uci_set(struct ubus_context *ctx, struct ubus_object *obj,
  *  3) if the blob is NULL, delete entire section
  */
 static void
-rpc_uci_merge_delete(struct blob_attr *opt, struct uci_ptr *ptr)
+rpc_uci_merge_delete(struct blob_attr *opt, struct uci_ptr *ptr, const char *username)
 {
 	struct blob_attr *cur;
 	int rem;
@@ -883,6 +889,9 @@ rpc_uci_merge_delete(struct blob_attr *opt, struct uci_ptr *ptr)
 	if (rpc_uci_lookup(ptr) || !ptr->s)
 		return;
 
+	if (!rpc_uci_section_access(username, ptr->s, 'w'))
+		return;
+
 	if (!opt)
 	{
 		ptr->o = NULL;
@@ -927,6 +936,7 @@ rpc_uci_delete(struct ubus_context *ctx, struct ubus_object *obj,
 	struct uci_package *p = NULL;
 	struct uci_element *e, *tmp;
 	struct uci_ptr ptr = { 0 };
+	const char *username;
 
 	blobmsg_parse(rpc_uci_delete_policy, __RPC_D_MAX, tb,
 	              blob_data(msg), blob_len(msg));
@@ -943,14 +953,16 @@ rpc_uci_delete(struct ubus_context *ctx, struct ubus_object *obj,
 	if (uci_load(cursor, ptr.package, &p))
 		return rpc_uci_status();
 
+	username = rpc_session_get_username(tb[RPC_D_SESSION]);
+
 	if (tb[RPC_D_SECTION])
 	{
 		ptr.section = blobmsg_data(tb[RPC_D_SECTION]);
 
 		if (tb[RPC_D_OPTIONS])
-			rpc_uci_merge_delete(tb[RPC_D_OPTIONS], &ptr);
+			rpc_uci_merge_delete(tb[RPC_D_OPTIONS], &ptr, username);
 		else
-			rpc_uci_merge_delete(tb[RPC_D_OPTION], &ptr);
+			rpc_uci_merge_delete(tb[RPC_D_OPTION], &ptr, username);
 	}
 	else
 	{
@@ -964,9 +976,9 @@ rpc_uci_delete(struct ubus_context *ctx, struct ubus_object *obj,
 			ptr.section = e->name;
 
 			if (tb[RPC_D_OPTIONS])
-				rpc_uci_merge_delete(tb[RPC_D_OPTIONS], &ptr);
+				rpc_uci_merge_delete(tb[RPC_D_OPTIONS], &ptr, username);
 			else
-				rpc_uci_merge_delete(tb[RPC_D_OPTION], &ptr);
+				rpc_uci_merge_delete(tb[RPC_D_OPTION], &ptr, username);
 		}
 	}
 
@@ -1013,6 +1025,12 @@ rpc_uci_rename(struct ubus_context *ctx, struct ubus_object *obj,
 		goto out;
 	}
 
+	if (!rpc_uci_section_access(rpc_session_get_username(tb[RPC_R_SESSION]), ptr.s, 'w')) {
+		// we behave as if that section does not exist
+		cursor->err = UCI_ERR_NOTFOUND;
+		goto out;
+	}
+
 	if (uci_rename(cursor, &ptr))
 		goto out;
 
@@ -1060,6 +1078,10 @@ rpc_uci_order(struct ubus_context *ctx, struct ubus_object *obj,
 		if (uci_lookup_ptr(cursor, &ptr, NULL, true) || !ptr.s)
 			continue;
 
+		if (!rpc_uci_section_access(rpc_session_get_username(tb[RPC_O_SESSION]), ptr.s, 'w')) {
+			continue;
+		}
+
 		uci_reorder_section(cursor, ptr.s, i++);
 	}
 
-- 
2.9.0

